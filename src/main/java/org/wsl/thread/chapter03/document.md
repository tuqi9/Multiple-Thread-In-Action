Chapter03: 如何共享、发布对象，使它们能够安全的由多个线程同时访问？
1. 可见性(内存可见性),示例: chapter03.example.NoVisibility.java
   1. 造成内存可见性的原因是：编译器、处理器以及运行时都可能对操作的执行顺序做出调整。
   2. 为了解决内存可见性，要求：在访问共享且可变的变量时，要求所有线程在同一个锁上同步。加锁的含义不仅仅局限于互斥，还包括解决内存可见性。
   3. 解决内存可见性的方式2: Java提供的volatile关键字,当变量被申明为volatile变量后，编译器、运行时都会主要到这个变量是共享的而不会对它重排序。volatile变量不会被缓存在寄存器或者其他对处理器不可见的地方，因此读取volatile变量时总能返回最新的值。
   4. 不要过度依赖volatile 
2. 对象的发布与逸出
   1. 对象的发布是指: chapter03.example.UnsafeStates.java
      1. 将指向该对象的引用保存到其他代码可以访问的地方
      2. 或者在某一个非私有的方法中返回它的引用
      3. 或者将它传递到其他类的方法中
      4. 当一个人将你的QQ密码发布到互联网上后,无论是否有人使用你的QQ密码，它都已经变的不再安全
   2. 对象的逸出
      1. 当某个不该被发布的对象被发布时，就叫做逸出
3. 线程封闭：尽在单线程内访问数据，就不需要同步。
   1. Ad-hoc线程封闭
      1. Ad-hoc线程封闭是指，维护线程封闭性的职责完全由程序实现来承担。
      2. Ad-hoc线程封闭技术脆弱，因此在程序中尽量少用。
   2. 栈封闭
      1. 在栈封闭中，只能通过局部变量才能访问对象。因为局部变量的固有属性之一就是封闭在执行线程的栈中。
      2. 栈封闭与ThreadLocal不同。示例：StackClose.java
   3. ThreadLocal
      1. 常用于防止对可变的单实例变量（Singleton）或者全局变量进行共享。示例：ThreadLocalExample.java
      2. ThreadLocal<T>从概念上可以理解为Map<Thread, T>，但实际上ThreadLocal的实现并非如此